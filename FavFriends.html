<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>æ–°å¹´çƒŸèŠ±ï½œç²‰é‡‘æ¢¦å¹»é­”æ³•ï¼ˆæ–‡å­—ç¥ç¦ï¼‰</title>
  <style>
    html, body { margin:0; height:100%; background:#05070d; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; }
    .hud{
      position:fixed; left:16px; top:16px; z-index:2;
      font:14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:rgba(255,255,255,.9);
      background:rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      padding:10px 12px;
      backdrop-filter: blur(8px);
      user-select:none;
    }
    .hint{ opacity:.85; margin-top:6px; font-size:12px; }
  </style>
</head>
<body>
  <div class="hud">
    <div class="hint">ç‚¹å‡»ï¼šæ”¾çƒŸèŠ± + çœ‹ç¥ç¦ </div>
  </div>
  <canvas id="c"></canvas>

  <script>
    // ================= Canvas =================
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");

    function resize() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width  = Math.floor(innerWidth * dpr);
      canvas.height = Math.floor(innerHeight * dpr);
      canvas.style.width = innerWidth + "px";
      canvas.style.height = innerHeight + "px";
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    addEventListener("resize", resize, { passive:true });
    resize();

    // ================= Helpers =================
    const TAU = Math.PI * 2;
    const rand = (a, b) => a + Math.random() * (b - a);
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const pick = (arr) => arr[(Math.random() * arr.length) | 0];

    // ================= Palette (Gold-forward) =================
    const HUES = {
      gold:  [38, 42, 46, 50],
      peach: [20, 26, 32],
      rose:  [330, 340, 350],
      lilac: [290, 300, 308],
      pearl: [0],
    };

    function dreamyColor(kind="mix") {
      let h;
      if (kind === "gold")  h = pick(HUES.gold);
      else if (kind === "peach") h = pick(HUES.peach);
      else if (kind === "rose")  h = pick(HUES.rose);
      else if (kind === "lilac") h = pick(HUES.lilac);
      else if (kind === "pearl") h = 0;
      else {
        const r = Math.random();
        if (r < 0.58) h = pick(HUES.gold);
        else if (r < 0.80) h = pick(HUES.peach);
        else if (r < 0.92) h = pick(HUES.rose);
        else h = pick(HUES.lilac);
      }
      const isPearl = (kind === "pearl") || (Math.random() < 0.06);
      const s = isPearl ? rand(0, 12) : rand(72, 92);
      const l = isPearl ? rand(80, 92) : rand(55, 70);
      return { h, s, l };
    }
    const hsla = (c, a=1) => `hsla(${c.h}, ${c.s}%, ${c.l}%, ${a})`;

    function addGlow(x, y, r, color, alpha){
      ctx.globalCompositeOperation = "screen";
      const g = ctx.createRadialGradient(x, y, 0, x, y, r);
      g.addColorStop(0, hsla(color, alpha));
      g.addColorStop(0.35, hsla(color, alpha * 0.35));
      g.addColorStop(1, hsla(color, 0));
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(x, y, r, 0, TAU); ctx.fill();
      ctx.globalCompositeOperation = "source-over";
    }

    // ================= Background: Stars + Bokeh =================
    const bokeh = Array.from({ length: 18 }, () => ({
      x: Math.random(), y: Math.random(),
      r: rand(60, 170),
      c: dreamyColor(Math.random() < 0.72 ? "gold" : (Math.random() < 0.8 ? "peach" : "rose")),
      a: rand(0.03, 0.08),
      drift: rand(-0.0007, 0.0007),
      phase: rand(0, TAU)
    }));

    const stars = Array.from({ length: 140 }, () => ({
      x: Math.random(), y: Math.random(),
      r: rand(0.6, 1.4),
      a: rand(0.12, 0.45),
      tw: rand(0.004, 0.02),
      ph: rand(0, TAU),
    }));

    function drawBackground(now) {
      ctx.globalCompositeOperation = "source-over";
      ctx.fillStyle = "#05070d";
      ctx.fillRect(0, 0, innerWidth, innerHeight);

      const g = ctx.createRadialGradient(innerWidth*0.5, innerHeight*0.58, innerWidth*0.12, innerWidth*0.5, innerHeight*0.58, innerWidth*0.8);
      g.addColorStop(0, "rgba(0,0,0,0)");
      g.addColorStop(1, "rgba(0,0,0,0.58)");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, innerWidth, innerHeight);

      // bokeh
      ctx.globalCompositeOperation = "screen";
      for (const b of bokeh) {
        b.x = (b.x + b.drift + 1) % 1;
        const pulse = 0.75 + 0.25*Math.sin(now*0.001 + b.phase);
        const alpha = b.a * pulse;
        const x = b.x * innerWidth;
        const y = b.y * innerHeight;
        const rr = b.r * (0.9 + 0.15*Math.sin(now*0.0008 + b.phase));

        const gb = ctx.createRadialGradient(x, y, 0, x, y, rr);
        gb.addColorStop(0, hsla(b.c, alpha));
        gb.addColorStop(1, hsla(b.c, 0));
        ctx.fillStyle = gb;
        ctx.beginPath(); ctx.arc(x, y, rr, 0, TAU); ctx.fill();
      }
      ctx.globalCompositeOperation = "source-over";

      // stars
      ctx.globalCompositeOperation = "lighter";
      for (const s of stars) {
        const tw = s.a + 0.25*Math.sin(now*0.001*(1/s.tw) + s.ph);
        ctx.fillStyle = `rgba(255,255,255,${clamp(tw, 0.05, 0.75)})`;
        ctx.beginPath();
        ctx.arc(s.x*innerWidth, s.y*innerHeight, s.r, 0, TAU);
        ctx.fill();
      }
      ctx.globalCompositeOperation = "source-over";
    }

    // ================= Fireworks Physics =================
    const particles = [];
    const rockets = [];
    const gravity = 0.06;

    class Particle {
      constructor(x, y, vx, vy, color, life, size, kind="spark") {
        this.x = x; this.y = y;
        this.vx = vx; this.vy = vy;
        this.color = color;
        this.life = life;
        this.maxLife = life;
        this.size = size;
        this.kind = kind; // spark / petal / dust / willow
        this.twinkle = Math.random() < (kind==="dust" ? 0.75 : 0.35);
        this.spin = rand(-0.14, 0.14);
        this.rot  = rand(0, TAU);
        this.flicker = rand(0.6, 1.6);
        this.extraDrag = (kind === "willow") ? rand(0.982, 0.989) : null;
      }
      step() {
        let drag = 0.988;
        if (this.kind === "petal") drag = 0.985;
        if (this.kind === "willow") drag = this.extraDrag;

        this.vx *= drag;
        this.vy *= drag;

        let g = gravity;
        if (this.kind === "dust") g = gravity * 0.35;
        if (this.kind === "willow") g = gravity * 1.15;

        this.vy += g;

        if (this.kind === "dust") {
          this.vx += Math.sin((this.x + this.y) * 0.01) * 0.01;
          this.vy += Math.cos((this.x - this.y) * 0.01) * -0.008;
        }

        this.x += this.vx;
        this.y += this.vy;

        this.rot += this.spin;
        this.life -= 1;
      }
      draw() {
        const t = this.life / this.maxLife;
        const alphaBase = clamp(t, 0, 1);

        let a = alphaBase;
        if (this.twinkle) {
          a *= (0.55 + 0.45 * Math.sin((1-alphaBase)*12*this.flicker + this.x*0.02));
        }

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rot);

        if (this.kind === "petal") {
          ctx.strokeStyle = hsla(this.color, a);
          ctx.lineWidth = Math.max(1, this.size * 0.55);
          ctx.beginPath();
          ctx.moveTo(-this.size*0.9, 0);
          ctx.quadraticCurveTo(0, -this.size*0.9, this.size*0.9, 0);
          ctx.quadraticCurveTo(0, this.size*1.0, -this.size*0.9, 0);
          ctx.stroke();
        } else if (this.kind === "willow") {
          ctx.strokeStyle = hsla(this.color, a);
          ctx.lineWidth = Math.max(1, this.size * 0.55);
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(-this.vx * 1.4, -this.vy * 1.4);
          ctx.stroke();
        } else {
          ctx.fillStyle = hsla(this.color, a * 0.95);
          ctx.beginPath();
          ctx.arc(0, 0, Math.max(0.65, this.size * (this.kind==="dust" ? 0.8 : 1)), 0, TAU);
          ctx.fill();
        }

        ctx.restore();

        if (alphaBase > 0.64 && Math.random() < (this.kind==="willow" ? 0.14 : 0.08)) {
          addGlow(this.x, this.y, 18 + this.size*12, this.color, 0.30);
        }
      }
      dead() { return this.life <= 0; }
    }

    class Rocket {
      constructor(x, y, ty, shape="burst") {
        this.x = x; this.y = y;
        this.ty = ty;
        this.vx = rand(-1.1, 1.1);
        this.vy = rand(-12.8, -9.8);
        this.shape = shape;
        this.trail = [];
        this.core = dreamyColor("pearl");
        this.tint = dreamyColor("gold");
        this.alive = true;
      }
      step() {
        this.vy += gravity * 0.14;
        this.vx *= 0.996;
        this.x += this.vx;
        this.y += this.vy;

        this.trail.push({ x: this.x, y: this.y });
        if (this.trail.length > 22) this.trail.shift();

        if (this.y <= this.ty + 10 || this.vy > -2.2) {
          this.explode();
          this.alive = false;
        }
      }
      draw() {
        ctx.save();
        ctx.globalCompositeOperation = "screen";
        for (let i = 0; i < this.trail.length; i++) {
          const p = this.trail[i];
          const a = i / this.trail.length;
          const c = (Math.random() < 0.82) ? dreamyColor("gold") : dreamyColor("peach");
          ctx.fillStyle = hsla(c, a * 0.28);
          ctx.beginPath();
          ctx.arc(p.x, p.y, 2.0, 0, TAU);
          ctx.fill();
        }

        ctx.fillStyle = hsla(this.core, 1);
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2.9, 0, TAU);
        ctx.fill();

        addGlow(this.x, this.y, 38, this.tint, 0.22);
        ctx.restore();
      }
      explode() {
        if (this.shape === "heart") spawnHeart(this.x, this.y);
        else if (this.shape === "flower") spawnFlower(this.x, this.y);
        else if (this.shape === "willow") spawnWillow(this.x, this.y);
        else if (this.shape === "layered") spawnLayeredMagic(this.x, this.y);
        else spawnBurst(this.x, this.y);
      }
    }

    function spawnBurst(x, y) {
      const count = Math.floor(rand(120, 200));
      const speed = rand(3.0, 6.0);

      for (let i = 0; i < count; i++) {
        const ang = (i / count) * TAU + rand(-0.02, 0.02);
        const r = speed * (0.65 + Math.random());
        const vx = Math.cos(ang) * r;
        const vy = Math.sin(ang) * r;
        const kind = Math.random() < 0.72 ? "gold" : "peach";
        particles.push(new Particle(x, y, vx, vy, dreamyColor(kind), Math.floor(rand(65, 110)), rand(1.0, 2.2), "spark"));
      }

      const dustCount = Math.floor(rand(45, 85));
      for (let i = 0; i < dustCount; i++) {
        const ang = rand(0, TAU);
        const sp = rand(0.5, 2.1);
        const vx = Math.cos(ang) * sp + rand(-0.2, 0.2);
        const vy = Math.sin(ang) * sp + rand(-0.2, 0.2);
        const roll = Math.random();
        const c = roll < 0.70 ? dreamyColor("gold") : (roll < 0.88 ? dreamyColor("rose") : dreamyColor("lilac"));
        particles.push(new Particle(x, y, vx, vy, c, Math.floor(rand(80, 140)), rand(0.8, 1.4), "dust"));
      }

      addGlow(x, y, 130, dreamyColor("pearl"), 0.18);
    }

    function spawnWillow(x, y) {
      const strands = Math.floor(rand(140, 220));
      const speed = rand(2.2, 4.2);
      const spread = rand(0.85, 1.15);

      addGlow(x, y, 170, dreamyColor("pearl"), 0.22);

      for (let i = 0; i < strands; i++) {
        const ang = (i / strands) * TAU + rand(-0.03, 0.03);
        const r = speed * (0.6 + Math.random() * spread);
        const vx = Math.cos(ang) * r * rand(0.9, 1.1);
        const vy = Math.sin(ang) * r * rand(0.9, 1.1) + rand(0.6, 1.6);
        const c = (Math.random() < 0.85) ? dreamyColor("gold") : dreamyColor("peach");
        particles.push(new Particle(x, y, vx, vy, c, Math.floor(rand(95, 155)), rand(1.2, 2.6), "willow"));
      }

      const dust = Math.floor(rand(60, 110));
      for (let i = 0; i < dust; i++) {
        const ang = rand(0, TAU);
        const sp = rand(0.3, 1.6);
        particles.push(new Particle(
          x, y,
          Math.cos(ang)*sp + rand(-0.15, 0.15),
          Math.sin(ang)*sp + rand(0.2, 0.8),
          dreamyColor("gold"),
          Math.floor(rand(95, 165)),
          rand(0.7, 1.2),
          "dust"
        ));
      }
    }

    function spawnLayeredMagic(x, y) {
      addGlow(x, y, 190, dreamyColor("pearl"), 0.26);

      const innerCount = Math.floor(rand(70, 120));
      const innerSpeed = rand(2.2, 3.6);
      for (let i = 0; i < innerCount; i++) {
        const ang = (i / innerCount) * TAU + rand(-0.02, 0.02);
        const sp = innerSpeed * (0.7 + Math.random());
        const vx = Math.cos(ang) * sp;
        const vy = Math.sin(ang) * sp;
        const c = (Math.random() < 0.6) ? dreamyColor("rose") : dreamyColor("lilac");
        particles.push(new Particle(x, y, vx, vy, c, Math.floor(rand(60, 95)), rand(0.9, 1.8), "spark"));
      }
      addGlow(x, y, 150, dreamyColor("rose"), 0.12);

      const midCount = Math.floor(rand(110, 170));
      const midSpeed = rand(3.4, 5.0);
      for (let i = 0; i < midCount; i++) {
        const ang = (i / midCount) * TAU + rand(-0.02, 0.02);
        const sp = midSpeed * (0.65 + Math.random());
        particles.push(new Particle(
          x, y,
          Math.cos(ang)*sp,
          Math.sin(ang)*sp,
          dreamyColor(Math.random()<0.78 ? "gold" : "peach"),
          Math.floor(rand(70, 115)),
          rand(1.0, 2.2),
          "spark"
        ));
      }
      addGlow(x, y, 175, dreamyColor("gold"), 0.14);

      const outer = Math.floor(rand(120, 190));
      const outerSpeed = rand(1.9, 3.2);
      for (let i = 0; i < outer; i++) {
        const ang = (i / outer) * TAU + rand(-0.03, 0.03);
        const sp = outerSpeed * (0.55 + Math.random());
        const vx = Math.cos(ang) * sp;
        const vy = Math.sin(ang) * sp + rand(0.8, 1.9);
        particles.push(new Particle(
          x, y,
          vx, vy,
          dreamyColor("gold"),
          Math.floor(rand(100, 165)),
          rand(1.2, 2.8),
          "willow"
        ));
      }

      const dust = Math.floor(rand(70, 120));
      for (let i = 0; i < dust; i++) {
        const ang = rand(0, TAU);
        const sp = rand(0.4, 1.8);
        particles.push(new Particle(
          x, y,
          Math.cos(ang)*sp + rand(-0.12, 0.12),
          Math.sin(ang)*sp + rand(0.15, 0.9),
          dreamyColor("gold"),
          Math.floor(rand(95, 175)),
          rand(0.7, 1.2),
          "dust"
        ));
      }
    }

    function spawnHeart(x, y) {
      const points = 160;
      const scale = rand(6.2, 8.4);
      const rot = rand(-0.25, 0.25);
      const speed = rand(0.34, 0.56);

      for (let i = 0; i < points; i++) {
        const t = (i / points) * TAU;
        let hx = 16 * Math.pow(Math.sin(t), 3);
        let hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
        hx *= scale * 0.08;
        hy *= -scale * 0.08;

        const rx = hx * Math.cos(rot) - hy * Math.sin(rot);
        const ry = hx * Math.sin(rot) + hy * Math.cos(rot);

        const vx = rx * speed + rand(-0.22, 0.22);
        const vy = ry * speed + rand(-0.22, 0.22);

        const c = (Math.random() < 0.62) ? dreamyColor("rose") : dreamyColor("gold");
        particles.push(new Particle(x, y, vx, vy, c, Math.floor(rand(75, 125)), rand(1.1, 2.0), "spark"));
      }

      const fill = 85;
      for (let i = 0; i < fill; i++) {
        const ang = rand(0, TAU);
        const sp = rand(0.4, 2.0);
        particles.push(new Particle(
          x, y,
          Math.cos(ang)*sp + rand(-0.12, 0.12),
          Math.sin(ang)*sp + rand(-0.12, 0.12),
          dreamyColor("gold"),
          Math.floor(rand(90, 155)),
          rand(0.75, 1.35),
          "dust"
        ));
      }

      addGlow(x, y, 160, dreamyColor("rose"), 0.13);
      addGlow(x, y, 170, dreamyColor("gold"), 0.10);
    }

    function spawnFlower(x, y) {
      const petals = Math.floor(rand(12, 18));
      const rings = 3;
      const baseSpeed = rand(3.0, 5.6);

      for (let r = 0; r < rings; r++) {
        const ringCount = Math.floor(rand(60, 95));
        const ringSpeed = baseSpeed * (0.55 + r * 0.22);
        for (let i = 0; i < ringCount; i++) {
          const ang = (i / ringCount) * TAU + rand(-0.02, 0.02);
          const wobble = 0.55 + 0.45*Math.sin(ang * petals);
          const sp = ringSpeed * wobble * rand(0.85, 1.10);

          const kind = (r === 0) ? "gold" : (r === 1 ? "rose" : "peach");
          particles.push(new Particle(
            x, y,
            Math.cos(ang)*sp,
            Math.sin(ang)*sp,
            dreamyColor(kind),
            Math.floor(rand(70, 120)),
            rand(1.0, 2.0),
            "spark"
          ));
        }
      }

      const petalCount = Math.floor(rand(60, 92));
      for (let i = 0; i < petalCount; i++) {
        const ang = rand(0, TAU);
        const sp = rand(2.0, 4.9);
        const color = dreamyColor(Math.random()<0.75 ? "gold" : "rose");
        particles.push(new Particle(x, y, Math.cos(ang)*sp, Math.sin(ang)*sp, color, Math.floor(rand(75, 125)), rand(2.2, 3.8), "petal"));
      }

      addGlow(x, y, 160, dreamyColor("gold"), 0.15);
    }

    // ================= æ–‡å­—ç¥ç¦ï¼ˆç‚¹å‡»ä¸€æ¬¡å‡ºç°ä¸€æ®µï¼‰ =================
    const blessings = [
       "2026 æœ‹å‹ä»¬ æ–°å¹´å¿«ä¹",
       "æ„¿æ–°å¹´ æœ‰æ±‚å¸åº”ğŸª™",
       "æ„¿æ–°å¹´ é£ç”Ÿæ°´èµ·ğŸ",
       "æ„¿æ–°å¹´ æ—ºåˆ°èµ·é£ğŸª",
       "æ»¡å¿ƒç¥æ„¿ å®¶äººä»¬ é•¿ä¹å®‰åº·",
       "å¹´å¤ä¸€å¹´ å¹´èµ´ä¸€å¹´ å¹´å¯Œä¸€å¹´",
       "æ›´ç¥å’±ä»¬ç°å® ç™¾äº‹å¯çˆ±",
       "ä¹Ÿç¥å°è…»è…» æ— ç¾æ— éš¾"

    ];
    let blessIndex = 0;

    // æ–‡å­—è‰²ï¼šé‡‘/ç²‰/ç™½éšæœºç»„åˆ
    const TEXT_COLORS = [
      "rgba(255, 215, 120, 1)", // é‡‘
      "rgba(255, 160, 205, 1)", // ç²‰
      "rgba(255, 255, 255, 1)"  // ç™½
    ];
    function randomTextTriplet(){
      // ä¿è¯è‡³å°‘æœ‰ä¸€ä¸ªé‡‘è‰²ï¼ˆâ€œé‡‘è‰²æ›´å¼ºâ€ï¼‰
      const a = TEXT_COLORS[0];
      const b = TEXT_COLORS[(1 + (Math.random()*2|0))]; // ç²‰æˆ–ç™½
      const c = TEXT_COLORS[(Math.random()*3|0)];
      // æ‰“ä¹±ä¸€ä¸‹
      const arr = [a,b,c];
      for(let i=arr.length-1;i>0;i--){
        const j = (Math.random()*(i+1))|0;
        [arr[i],arr[j]] = [arr[j],arr[i]];
      }
      return arr;
    }

    const textOverlays = []; // {text, t0, dur, colors}
    function showNextBlessing(now){
      const text = blessings[blessIndex % blessings.length];
      blessIndex++;

      textOverlays.push({
        text,
        t0: now,
        dur: 3200,              // æ€»æ—¶é•¿ï¼š3.2sï¼ˆæ·¡å…¥+åœç•™+æ·¡å‡ºï¼‰
        colors: randomTextTriplet()
      });
      // æ§åˆ¶æœ€å¤š1ä¸ªï¼Œé¿å…ç‚¹å¤ªå¿«å †å 
      if (textOverlays.length > 1) textOverlays.shift();
    }

    // æ ¹æ®å±å¹•è®©æ–‡å­—â€œå 40%é«˜åº¦å·¦å³â€
    function computeFontSize(){
      const H = innerHeight;
      // å¤§å­—ï¼šç›®æ ‡å—é«˜åº¦â‰ˆ40%å±å¹•ã€‚è¿™é‡Œç”¨ç»éªŒå€¼ï¼šå­—å·â‰ˆå±é«˜çš„ 12%~15%
      return Math.floor(clamp(H * 0.13, 44, 120));
    }

    function wrapText(text, maxWidth, font){
      ctx.save();
      ctx.font = font;
      const words = text.split(/\s+/); // å¦‚æœæœ‰ç©ºæ ¼æŒ‰ç©ºæ ¼ï¼›æ²¡æœ‰ç©ºæ ¼å°±æŒ‰å­—ç¬¦
      let lines = [];

      if (words.length > 1) {
        let line = "";
        for (const w of words) {
          const test = line ? (line + " " + w) : w;
          if (ctx.measureText(test).width <= maxWidth) line = test;
          else { lines.push(line); line = w; }
        }
        if (line) lines.push(line);
      } else {
        // ä¸­æ–‡æ— ç©ºæ ¼ï¼šæŒ‰å­—ç¬¦æŠ˜è¡Œ
        let line = "";
        for (const ch of text) {
          const test = line + ch;
          if (ctx.measureText(test).width <= maxWidth) line = test;
          else { lines.push(line); line = ch; }
        }
        if (line) lines.push(line);
      }

      ctx.restore();
      return lines;
    }

    function drawBlessings(now){
      if (textOverlays.length === 0) return;

      const overlay = textOverlays[0];
      const t = (now - overlay.t0) / overlay.dur;
      if (t >= 1) { textOverlays.shift(); return; }

      // alphaï¼šæ·¡å…¥(0~0.18) -> åœç•™ -> æ·¡å‡º(0.70~1)
      let alpha = 1;
      if (t < 0.18) alpha = t / 0.18;
      else if (t > 0.70) alpha = (1 - t) / 0.30;
      alpha = clamp(alpha, 0, 1);

      const fontSize = computeFontSize();
      const font = `700 ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      const maxWidth = innerWidth * 0.82; // æ–‡æœ¬å—å®½åº¦
      const lines = wrapText(overlay.text, maxWidth, font);

      // è®©æ•´ä½“æ–‡æœ¬å—å±…ä¸­
      const lineHeight = fontSize * 1.18;
      const blockH = lines.length * lineHeight;
      const x = innerWidth * 0.5;
      const y = innerHeight * 0.5 - blockH / 2 + lineHeight * 0.8;

      // æ¸å˜å¡«å……ï¼ˆé‡‘ç²‰ç™½éšæœºï¼‰
      ctx.save();
      ctx.globalCompositeOperation = "screen";
      ctx.font = font;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      // æ–‡å­—æŸ”å…‰èƒŒæ™¯ï¼ˆè®©â€œé­”æ³•â€æ›´åƒç…§ç‰‡äº®æ ¸ï¼‰
      const glowColor = dreamyColor("gold");
      addGlow(innerWidth*0.5, innerHeight*0.5, Math.min(innerWidth,innerHeight)*0.35, glowColor, 0.12 * alpha);

      // æ¸å˜
      const grad = ctx.createLinearGradient(x - maxWidth/2, 0, x + maxWidth/2, 0);
      grad.addColorStop(0, overlay.colors[0]);
      grad.addColorStop(0.5, overlay.colors[1]);
      grad.addColorStop(1, overlay.colors[2]);

      // å¤–å‘å…‰æè¾¹ï¼ˆç™½+é‡‘ï¼‰
      ctx.lineJoin = "round";
      ctx.lineWidth = Math.max(6, fontSize * 0.10);
      ctx.strokeStyle = `rgba(255,255,255,${0.35 * alpha})`;
      ctx.shadowColor = "rgba(255, 215, 160, 0.85)";
      ctx.shadowBlur = Math.max(18, fontSize * 0.55);

      for (let i = 0; i < lines.length; i++) {
        const yy = y + i * lineHeight;
        ctx.strokeText(lines[i], x, yy);
      }

      // ä¸»å¡«å……
      ctx.shadowBlur = Math.max(10, fontSize * 0.35);
      ctx.fillStyle = grad;
      for (let i = 0; i < lines.length; i++) {
        const yy = y + i * lineHeight;
        ctx.fillText(lines[i], x, yy);
      }

      ctx.restore();
    }

    // ================= Spawning =================
    let lastAuto = 0;

    function spawnAuto(now) {
      const interval = clamp(520 - innerWidth*0.12, 240, 520);
      if (now - lastAuto < interval) return;
      lastAuto = now;

      const bursts = Math.random() < 0.30 ? 2 : 1;
      for (let i = 0; i < bursts; i++) {
        const x  = rand(innerWidth*0.15, innerWidth*0.85);
        const y0 = innerHeight + rand(10, 60);
        const ty = rand(innerHeight*0.18, innerHeight*0.45);

        const roll = Math.random();
        const shape =
          roll < 0.16 ? "heart" :
          roll < 0.34 ? "flower" :
          roll < 0.66 ? "layered" :
          "willow";

        rockets.push(new Rocket(x, y0, ty, shape));
      }
    }

    function spawnAt(x, y) {
      const fromX = x + rand(-55, 55);
      const fromY = innerHeight + rand(20, 95);

      const roll = Math.random();
      const shape =
        roll < 0.20 ? "heart" :
        roll < 0.40 ? "flower" :
        roll < 0.72 ? "layered" :
        "willow";

      rockets.push(new Rocket(fromX, fromY, y, shape));
    }

    // âœ… ç‚¹å‡»ä¸€æ¬¡ï¼šå‘å°„çƒŸèŠ± + å¼¹å‡ºç¥ç¦ï¼ˆåªåœ¨ pointerdown è§¦å‘ä¸€æ¬¡ï¼‰
    addEventListener("pointerdown", (e) => {
      spawnAt(e.clientX, e.clientY);
      showNextBlessing(performance.now());
    });

    // æ‹–æ‹½æ—¶ç»§ç»­å‡ºçƒŸèŠ±ï¼ˆä½†ä¸é‡å¤å‡ºæ–‡å­—ï¼‰
    let pointerDown = false;
    addEventListener("pointerdown", () => { pointerDown = true; });
    addEventListener("pointermove", (e) => {
      if (!pointerDown) return;
      if (Math.random() < 0.35) spawnAt(e.clientX, e.clientY);
    });
    addEventListener("pointerup", () => pointerDown = false);
    addEventListener("pointercancel", () => pointerDown = false);

    // ================= Main loop =================
    function loop(now) {
      try {
        drawBackground(now);

        // æ‹–å½±
        ctx.globalCompositeOperation = "source-over";
        ctx.fillStyle = "rgba(5,7,13,0.20)";
        ctx.fillRect(0, 0, innerWidth, innerHeight);

        spawnAuto(now);

        // rockets
        for (let i = rockets.length - 1; i >= 0; i--) {
          const r = rockets[i];
          r.step(); r.draw();
          if (!r.alive) rockets.splice(i, 1);
        }

        // particles
        ctx.globalCompositeOperation = "screen";
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.step();
          p.draw();
          if (p.dead()) particles.splice(i, 1);
        }
        ctx.globalCompositeOperation = "source-over";

        // âœ… ç¥ç¦æ–‡å­—ï¼ˆæœ€åç”»ï¼Œè¦†ç›–åœ¨æœ€ä¸Šå±‚ï¼‰
        drawBlessings(now);

        requestAnimationFrame(loop);
      } catch (err) {
        console.error("è„šæœ¬å‡ºé”™ï¼š", err);
      }
    }
    requestAnimationFrame(loop);

    // åˆå§‹å±•ç¤º
    setTimeout(() => {
      const xs = [0.28, 0.50, 0.72].map(v => v*innerWidth);
      rockets.push(new Rocket(xs[0], innerHeight+40, innerHeight*0.30, "willow"));
      rockets.push(new Rocket(xs[1], innerHeight+40, innerHeight*0.28, "layered"));
      rockets.push(new Rocket(xs[2], innerHeight+40, innerHeight*0.32, "willow"));
    }, 220);

  </script>
</body>
</html>
